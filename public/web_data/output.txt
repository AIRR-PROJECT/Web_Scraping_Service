[{
    "title": "Nestjs Series- Interceptors",
    "tags": ["#nestjs", "#javascript", "#backenddev"],
    "link": "https://dev.to/vignesh_pugaz/nestjs-series-interceptors-56o1",
    "reactions": 4,
    "cmt": null,
    "content": "Introduction\n\tInterceptors are classes decorated with @Injectable() decorator. The core concept of interceptors is based on Aspect Oriented Programming (AOP) paradigm. AOP is a programming paradigm to that aims to increase the modularity by allowing the separation of cross-cutting concerns.\n\tInterceptors are useful in the following scenarios:\n\tEach interceptor class has to implement the NestInterceptor interface and thus have to satisfy all the method contracts.\nintercept() is such a method, taking 2 arguments. First argument is ExecutionContext, which we have already discussed in nestjs pipes and guards. ExecutionContext inherits the ArgumentsHost which is a wrapper around the arguments that have been passed to the handler. By inheriting the ArgumentsHost, it has several methods to provide details about the current execution context. The second argument to intercept() is of type CallHandler. CallHandler inherits the handle() method which is used to call the route handler method at any point of the execution. This is called the Pointcut, where in additional or transformed information is being passed to the route handler method.\n\tThis means that the interceptor kind of wraps the request/response stream and thus can manipulate some logic before and after the route handler method calls. The handle() method returns an Observable, so we can use operators from rxjs to collect the response stream.\n\tThe below code snippet is taken from the official nestjs docs to cover the basic understanding of interceptors.\n\tFollowing code snippet is used to get the request object and perform some operations on it:\n\tAbove code is very obvious. tap() operator of rxjs library is used to execute an anonymous function once the entire response stream is captured from the method handler().\n\nBinding Interceptors\n\tAs with Guards and Pipes, Interceptors can be binded at one of the following three levels:\n\tAll you have to do is to decorator the levels with @UseInterceptors() decorator and pass on the Interceptor class or an instance of it as shown in the code below:\n\tAt the global level:\n\tAnd at the module level:\n\tInterceptors can be used to timeout a request handler manually. When your endpoint doesn't return anything after a period of time, you want to terminate with an error response. The following construction enables this:\n\n"
}, {
    "title": "NestJS Discovery",
    "tags": ["#nestjs", "#typescript", "#node", "#intermediate"],
    "link": "https://dev.to/sfeircode/nestjs-discovery-15kd",
    "reactions": 22,
    "cmt": 1,
    "content": "Context\n\tThere is quite a feature available in NestJS that is, as of today, still undocumented.\n\tI recently joined a new project, and there is a monitoring service that needs to access all repositories running in our app.\n\tI was surprised that there didn't seem to be a better way that injecting manually all of them:\n\tAs I was discovering this service, a few things came in mind:\n\nDiscovering my repositories: how to ?\n\tThere are already a lot of decorators in the NestJS ecosystem, and they mostly work all the same: by setting Reflection Metadata to the target.\n\tSo we are going to play like them, by first tagging our repositories with a custom Metadata.\n\tOnce we tagged them, we will ask the DiscoveryService to give us all the registered providers, with this.discoveryService.getProviders().\nThis method returns us a collection of type InstanceWrapper = { metatype, name, instance, ... }.\n\tThe custom Metadata, we used to tag our services with, will be linked to the wrapper.metatype.\n\nPimp my services\n\tSo let's start by doing the same and define a custom metadata through a custom decorator:\n\tNB: SetMetadata is documented for route handlers, with the usage of NestJS's Reflector.\n\tNow we can start to tag the repositories:\n\tYou know the drill, we can also define a custom Repository decorator:\n\nBring them all\n\tLet's define our Registry which will use the DiscoveryService to find all providers tagged with our custom Metadata.\n\tWe will first wait for onModuleInit to make sure all providers are registered.\n\tThen we will retrieve all providers instance wrappers from the DiscoveryService,\n\tFilter them on our custom Metadata,\n\tAnd finally, group the instances by the value of the aforementioned Metadata.\n\tAfter some refactoring:\n\tDon't forget to import the DiscoveryModule !\n\nAnd in the darkness, bind them.\n\tNow that we tagged our services and now that we can find them all, let's refactor our pain point:\n\tBefore:\n\tAfter:\n\nThoughts\n\tNo really private providers\n\t\tEven if your tagged providers aren't exported anywhere, NestJS's DiscoveryService will be able to discover them.\n\t\tI find this behaviour quite great, since it allows me to discover them without forcing me to expose services I don't want available for DI.\n\t\tHowever, this worries me since nothing can really reassure me that another module isn't mutating/patching my \"private\" providers instances at runtime.\n\n\tControllers\n\t\tDiscoveryService exposes getControllers() too, since they are treated differently than a provider in NestJS.\n\t\tYou may need to extend the previous snippets to handle them as well, if you need.\n\n\tGlobal\n\t\tI couldn't tell if it would be a good idea to make RegistryModule a global module.\n\n\tLifecycle\n\t\tI hooked the explorer to onModuleInit but I probably should have waited to load the providers later, like during onApplicationBootstrap.\n\t\tI am not confident enough in my knowledge of the lifecycle to tell today.\n\t\tI guess all providers are already registered during onModuleInit ?\n\n\nSources\n\tFind me on Twitter @maxence_lfbvr\n\n"
}, {
    "title": "NestJS Repository DI using @InjectRepository is not working properly",
    "tags": ["#typescript", "#nestjs", "#beginners", "#codenewbie"],
    "link": "https://dev.to/vincentjang/nestjs-repository-di-using-injectrepository-is-not-working-properly-3bf8",
    "reactions": 5,
    "cmt": 2,
    "content": "NestJS 의 Service 에서는 다음과 같이 레포지토리를 연결한다.\nNestJS 공식 도큐먼트에서는 위와같이 사용하는것을 권장하는 듯 하다만,\n이렇게 개발하던 도중..\n갑자기 TypeOrm 에서 기존까지 잘 작업이 되다가 갑자기 띄운 500 에러와 함께 콘솔에 다음과 같은 오류를 띄웠다\n처음엔 TypeOrm 의 설정부분에서 .env 파일의 비동기화 문제로 모듈이나 레포지토리가 undefined 일 수 있다고 생각하여 콘솔로 찍어 보았지만, 해당 메소드 (.findOne) 와 모듈, 레포지토리는 정상적으로 존재했다.\n다음엔 TypeOrm 모듈이 문제일 수 있다고 판단하여 node_modules 를 싹 지우고 다시 npm install 을 해보았지만 증상은 그대로였다.\nStack-Overflow 에 검색 해본 결과 다음과 같은 해결책을 제시받았다.\n데코레이터 @InjectRepository 를 사용하지 않고\n자바와 같이 private 멤버로 명시적으로 선언하고 생성자에서 직접적으로 인스턴스를 넣어주는 방식을 사용하는 것이다.\n적용해 본 결과성공적으로 동작하였다.\n이유를 찾아보려고 했지만 쉽지 않아 먼저 스스로 시도했던 방법과 해결책만 간단히 적어둔다.\n"
}, {
    "title": "NestJS: Pode usar mais e mais!",
    "tags": ["#nestjs", "#typescript", "#node", "#javascript"],
    "link": "https://dev.to/tarcisio/nestjs-pode-usar-mais-e-mais-4lh9",
    "reactions": 5,
    "cmt": 3,
    "content": "Venho trabalhando com NestJS em meus projetos pessoais desde 2019, basicamente são projetos para expor pequenas APIs que servem a alguns poucos e pequenos sites.\nRecentemente tive a oportunidade de compor um time que estava usando NestJS de uma forma muito séria e fizemos a implementação de uma API muito robusta que esta escalando mais e mais.\nEstou muito satisfeito com o resultado que o NestJS tem nos proporcionado e isso me motivou a fazer esses post.\nO que é NestJS\n\tFramework de NodeJs que possibilita aos desenvolvedores de TypeScript e JavaScript criar aplicações eficientes e capazes de escalar de maneira muito simples e rápida.\nEscrevi TypeScript antes de JavaScript porque o NestJS é TypeScript first ou seja, todo o desenvolvimento é baseado em TypeScript mas é claro você ainda pode usar JavaScript (fique à lá vonté).\nUm detalhe sobre o NestJS, \"por baixo dos panos\" NestJS faz uso do nosso querido Express. Você não é obrigado usar o Express, você pode trocar por Fastify. Esse é um post padrão, então vai seguir com o Express no exemplo!\n\tPrimeiramente, vamos instalar e fazer uso da Nest CLI que é um command-line que vai nos ajudar a inicializar o projeto, nos ajuda no desenvolvimento e a manter o projeto também.\n$ npm i -g @nestjs/cli\n $ nest new project-name\n\tComo demonstração neste post vamos criar uma API para registro de contatos.\nExecute o comando:\nnest new api-contact\nQuando aparecer a pergunta - Which package manager would you ❤️ use? - selecione \"npm\".\nNavega até a pasta:\ncd api-contact\nVocê verá a seguinte estrutura inicial do projeto:\n\tO scaffolding do NestJS já traz vários arquivos de projetos que nos ajudam muito durante o desenvolvimento.\n\tUma coisa, antes de começar a codificar, vamos adicionar o TypeORM\n\tAgora que já temos a dependência do TypeORM instalado, vamos criar nossa primeira entidade.\nCrie um arquivo chamado contact.entity.ts\n\tAgora vamos fazer uma de uma DTO que será usada para salvar os registros de contatos, então crie o arquivo CreateContact.dto.ts:\n\tNão vou falar hoje sobre padrão Service Repository, mas pra quem conhece esse conceito vai identificar isso muito fácil no NestJS.\nCrie o arquivo contacts.service.ts:\n\tObviamente a repository do exemplo salva dados em um banco de dados.\nVou fornecer aqui as configurações que eu usei para o PostgreSQL. Para isso usei o arquivo app.module.ts que é padrão já fornecido pelo scaffolding do NestJS:\n\tPra facilitar a vida de quem acompanha esse post vou deixar o  arquivo docker-compose.yml disponível para quem tem interesse de já rodar a imagem de um PostgreSQL e testar a API.\n\tAté aqui eu só mostrei o exemplo do código de produção, ou seja o código que necessitamos para rodar a API de forma funcional.\nAgora, vamos ver a parte do código que corresponde aos Testes Unitários.\n\tPor padrão o NestJS já cria um arquivo de teste que vem junto com o scaffolding.\n\tPara esse exemplo vou deixar o código de testes unitários que usei para testar a nossa service, então veja o código do arquivo contacts.service.spec.ts:\n\tEu implementei alguns poucos testes, porém o que eu quero demonstrar é a facilidade que temos em montar nossos testes unitários com Jest e NestJS.\nVeja como é fluída a codificação dos testes.\n\tCódigo completo do exemplo no ❤️Github, onde tudo esta!\n\tConclusão\nNestJS é um framework muito estável e de fácil adoção em aplicações de todos os níveis de complexidade isso porque ele é muito simples de se usar e também porque Nest CLI já te serve uma ótima estrutura de código para começo de projeto e de fácil alteração e evolução.\n\n\n"
}, {
    "title": "Nestjs Series- Guards",
    "tags": ["#nestjs", "#javascript", "#webdev"],
    "link": "https://dev.to/vignesh_pugaz/nestjs-series-guards-4pn7",
    "reactions": 10,
    "cmt": null,
    "content": "Introduction\n\tGuards! As the name suggests,it guards something from being accessible without permissions. Guards are a common concept in most backend frameworks,be it provided by the underlying framework or custom coded by the developer. Nestjs makes it simple for us to protect and safe guard apis from unauthorized or unauthenticated users.\n\tLike pipes and filters, guards in nestjs are decorated with @Injectable() decorator.Every guard you use must implement the CanActivate interface. The CanActivate interface properties make it easy developers to custom code their own guard logic.\n\tLet's understand the difference between a middleware and a guard to protect routes. A middleware is completely unaware of what is to be executed after it. A guard on the other hand has access to the ExecutionContext instance and thus knows what is to be executed exactly after it.They are much like filters and pipes and can interpose the correct logic at the correct time in a Request-Response cycle.This property proves that a middleware is dumb.\n\tGuards are executed after each middleware and before and pipes or interceptors.\n\tLet's understand whatever is said with an example (the below code snippet is taken from nestjs official docs):\n\tGoing through the snippet, most of you must have understood the use of ExecutioContext.But what if one is wants to get the websocket connection context or a gql execution context. ExecutionContext covers all of them. All you need to do is switch to the appropriate context of your need and manipulate the logic. The ExecutionContext class extends the ArgumentsHost, providing you with the right methods to switch between the contexts. You can checkout the official docs as per your needs as this is out of the scope of this article.\n\tLet's talk about binding these guards now. As with pipes, filters and interceptors, guards can be controller-scoped,method-scoped or globally-scoped.Below we use a guard at the controller-scope level using @UseGuards() decorator.\n\tWe have passed the class name of the Guard to the decorator. You can even pass and instance to the Guard or even a list of instances or types.\n\nSetting up roles\n\tRoles are a way to tell the controller methods to allow the request-response cycle to complete.If a particular role is not authorized to access an endpoint, the request-response cycle is ended here by returning an unauthorized error message, typically with a 401 HTTP statuscode. Our guards are very smart but they do not know which roles are allowed for which endpoints.This is where custom metadata comes into play. With custom metadata, we can segregate endpoints based on the roles as shown below:\n\tNow we have assigned the roles to the updateReadWriteAccessOfUser method. Only the user with \"admin\" and \"superadmin\" roles can access this endpoint \"/updateAccess\".While this is enough for this concept to be understood, it is not a good practice to assign roles directly on the controller methods. Instead we can code our own decorator for this and use it. We code this such that it follows DRY solid principle.\n\tNow you can reuse this decorator whereever needed.\n\tNow we combine the concepts of roles and guards to protect our endpoint from unauthorized requests.\n\tThe Reflector helper class is provided by the nestjs framework to access the controller method's roles. We verify the roles the current request's roles and return a boolean based on the verification. In the second code snippet, we make use of this RolesGuard as a paramter to the applyDecorators. The applyDecorators method combines multiple decorators and executes them.\n\tAny exception thrown by a guard will be handled by the exceptions layer (global exceptions filter and any exceptions filters that are applied to the current context).\n\n"
}]